import numpy as np
import matplotlib.pyplot as plt
from DSIpy import DSISurrogate

# --- 1. Load Unconfined Data ---
print("Loading Unconfined Ensemble...")
# Ensure we are loading the _uc files generated by generate_unconfined_ensemble.py
obs_prior = np.load('obs_prior_uc.npy')
pred_prior = np.load('pred_prior_uc.npy')
field_data = np.load('field_data_uc.npy')
true_val = np.load('true_val_uc.npy')

# Define Noise (0.2m standard deviation)
obs_noise = np.ones_like(field_data) * 0.2

print(f"Ensemble Size: {obs_prior.shape[0]}")
print(f"Prediction: Drawdown (m)")
print(f"Prior Range: {pred_prior.min():.2f} m to {pred_prior.max():.2f} m")
# Note: Negative values here are valid (Mounding/Recharge)

# --- 2. Fit Surrogate ---
# Use 'log' transform for prediction ONLY if all values are positive.
# Since we have negative drawdown (mounding), we MUST use 'none' or shift the data.
# 'none' is safest for mixed +/- data.
dsi = DSISurrogate(
    obs_pca_variance=1,   # Keep 99% of Head variance
    pred_pca_variance=1,
    svd_variance=0.9999999999,# Keep 100% of Prediction variance
    log_transform_obs=False, # Heads are linear, not log-normal
    pred_transform='none'
)

print("\n--- Fitting Surrogate ---")
dsi.fit(obs_prior, pred_prior)

# --- 3. Inversion (ES-MDA) ---
print("\n--- Running ES-MDA Inversion ---")
mean, std, metrics, post_ens = dsi.predict(
    h_observed=field_data,
    obs_noise_std=obs_noise,
    inversion_type='ies',
    n_ies_iterations=5,
    n_posterior_samples=500, 
    return_ensemble=True
)

# --- 4. Diagnose Non-Linearity ---
print("\n--- Diagnosing Bias ---")
# Check if the "Thinning Aquifer" effect created a curve. 
# If it's a straight line, your drawdown is small relative to aquifer thickness.
dsi.diagnose_surrogate_bias(obs_prior, pred_prior, indices_to_plot=[0])

# --- 5. Bias Correction (Optional but Recommended) ---
print("\n--- Applying Bias Correction ---")
# Even if linear, Quantile Mapping is good practice to ensure the posterior
# doesn't drift outside the statistical bounds of the prior physics.
post_corr = dsi.apply_bias_correction(post_ens, obs_prior, pred_prior, method='auto')

# --- 6. Validation ---
plt.figure(figsize=(10,6))

# Histograms
plt.hist(pred_prior, bins=40, alpha=0.3, color='gray', density=True, label='Prior (Physics)')
plt.hist(post_ens, bins=40, alpha=0.5, color='red', density=True, label='Posterior (Raw)')
plt.hist(post_corr, bins=40, alpha=0.5, color='green', density=True, label='Posterior (Corrected)')

plt.axvline(true_val, color='black', linestyle='--', lw=3, label=f'Truth ({true_val.item():.2f}m)')

plt.xlabel("Drawdown (m) [Negative = Mounding]")
plt.ylabel("Probability Density")
plt.title("DSI Inversion: Unconfined Aquifer")
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
